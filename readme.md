 Kubernetes k8s

 https://www.youtube.com/watch?v=X48VuDVv0do&t=3725s

 Фрэймворк для оркестрации контейнерами.

 Node(Узел) - Kubernetes запускает ваши приложения, помещая контейнеры в Поды для запуска на Узлах (Nodes). В зависимости от кластера, узел может быть виртуальной или физической машиной. Каждый узел содержит сервисы, необходимые для запуска Подов, управляемых плоскостью управления.

 Pod(каждый под имеет свой ip) - это абстрактный объект Kubernetes, представляющий собой группу из одного или нескольких контейнеров приложения (например, Docker или rkt) и совместно используемых ресурсов для этих контейнеров.
 1 приложение - 1 под
 Если под умер, то при пересоздание, присваивается новй ip

 Service and Ingress

 	Service - содержит статический ip адрес. Service не связан с подом, если под сдох - сервис - жив, и сохраняет свое состояние.
 		External service - для подключения внешних ресурсов(смотрит наружу)(9 миин)
 		Internal service - для создания подключения внутренних ресурсов. (смотрит внутри)(9 мин)

	Ingress - это ресурс для добавления правил маршрутизации трафика из внешних источников в службы в кластере kubernetes. Запрос из внешних источников идет в ингрес, потом распределяется по сервисам.

	ConfigMap - позволяет разделять конфигурационные файлы и контейнеры с приложениями, избавляя от необходимости упаковывать конфиги в docker-образ. В данной статье рассмотрим несколько примеров использования конфигмапов
	Secret - предназначены для хранения конфиденциальной информации, такой как пароли, OAuth-токены или ssh-ключи.

	Volumes(data storage) -  это просто папка хоста, примонтированная к файловой системе контейнера. Так как технически она больше не принадлежит контейнеру, то последний можно смело удалять, пересоздавать заново, снова прикручивать к нему хостовые папки, и ничего с данными внутри не случится.
	Может находиться как локально, так и удаленно


Deployment & Stateful set - механизмы реплики

	Deployment — то объект Kubernetes, представляющий работающее приложение в кластере. При создании объекта Deployment вы можете указать в его поле spec, что хотите иметь три реплики приложения. Система Kubernetes получит спецификацию объекта Deployment и запустит три экземпляра приложения, таким образом обновит статус (состояние) объекта, чтобы он соответствовал заданной спецификации. В случае сбоя одного из экземпляров (это влечет за собой изменение состояние), Kubernetes обнаружит несоответствие между спецификацией и статусом и исправит его, т.е. активирует новый экземпляр вместо того, который вышел из строя.

	По факту работаем с deployment а не pods

	Stateful set  — это удобный способ работы со Stateful-приложениями, которым требуется обрабатывать события об остановке работы Pod и осуществления Graceful Shutdown. Обычно, такие приложения — это базы данных и очереди сообщений, которые работают в нескольких экземплярах, синхронизируемых друг с другом посредством репликации или кластеризации.

Архитектура.
	Node
	- каждая нода имеет множественное количество подов
	- есть минимум 3 установленных процесса(Kublet, Kube Proxy, Conteiner runtime)
	- воркер ноды для созданяир актуальной работы

	container runtime - к примеру Docker, «среда запуска»

	Kubelet - Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.
	Утилита kubelet принимает набор PodSpecs, и гарантирует работоспособность и исправность определённых в них контейнеров. Агент kubelet не отвечает за контейнеры, не созданные Kubernetes. Назанчает ресурсы поду(cpu, ram, storage capacity) из ноды.
	Kubectl — это инструмент командной строки для управления кластерами Kubernetes.

	Kube-proxy - сетевой прокси, работающий на каждом узле в кластере, и реализующий часть концепции сервис. kube-proxy конфигурирует правила сети на узлах. При помощи них разрешаются сетевые подключения к вашими подам изнутри и снаружи кластера.

Master process - это коллекция из трех процессов, которые выполняются на одном узле в вашем кластере, который обозначен как главный узел. Это процессы: kube-apiserver, kube-controller-manager и kube-scheduler.

	kube-apiserver предназначен для горизонтального масштабирования, то есть развёртывание на несколько экземпляров. Вы можете запустить несколько экземпляров kube-apiserver и сбалансировать трафик между этими экземплярами.

	Kube-scheduler является неотъемлемым компонентом Kubernetes, который отвечает за планирование подов по нодам в соответствии с заданными политиками. Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.

	kube-controller-manager Компонент Control Plane запускает процессы контроллера. Контроллер - Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.

	etcd - Распределённое и высоконадёжное хранилище данных в формате "ключ-значение", которое используется как основное хранилище всех данных кластера в Kubernetes.

	Add new Master/Node server
	1) get new bare server
	2) install all the master/worker node processes
	3) add it to the cluster


Yaml configs
	Храним вместе с кодом, либо в отдельном репозитории.

	состоит и 3ех частей.
	apiVersion - версия app
	kind: тип компонента(service, deployment)
	1) metadata
		name - имя
		labels - лэйбл используется сервисом
	2) specification(spec)
		replicas (число реплик)
		selector - свзяывает поды с деплойментом
		  matchLabels:
		    app:
		template
			metadata
			  name
			  label - показывает связь с селектором
			spec
			  containers:
			    name:
			    image:
			    ports: порты необходимо настраивать между сервисом и деплоем


	3) status - автоматически генерируемый кубером

кодируем для секрета
echo -n 'username' | base64

NameSpace
    Виртуальный кластер в кластере кубернетес
    Можно разложить по абстрактным сущностям. - Database, Monitoring
    Можно использовать для различных ролей.
    Можно задавать ресурсы, для каждого namespace

Ingress
Пересмотреть ingress 2:01 еще раз
Если кратко, настраиваем маршруты добавляя dns и https


Minikube

	{} - шаблонизитор - не прописываем, пишем просто

	minikube
	  minikube start
	  minikube stop
	  minikube status

	kubectl
	 kubectl get nodes       // получить список node
	 kubectl get pod 	     // получить список pod
	 kubectl get services    // получить список services
	 kubectl get deployments // получить deployment
	 kubectl get replicaset  // получить replicaset

	 // создание компонентов
	 component
	   deployment
	   pod
	   nodes
	   service
	   replicaset

	 kubectl - никогда не создает поды, если хотим создать под(ы)
	 работаем с deployment
 	 создание

	 kubectl create {component} {name} --image={image-name}
	 изменение
	 kubectl edit {component} {name}

	 debugging
	 kubectl logs {pod-name}

	 доп информация
	 kubectl describe {component} {name}

	 получить доступ к терминалу контейнера
	 kubectl exec -it {pod name} -- bin/bash

	 развертывание через файл(config-file.yaml)
	 kubectl apply -f {file name}

	 //получить поды gitlaba
	 kubectl -n gitlab-managed-apps

 	 // полное креды компонента
	 kubectl get {component} -o wide

	 //получить из etcd yaml компонента(удобно для дебага )
	 kubectl get {component} nginx-dep -o yaml > nginx-depl.yaml


	 !!! можно удалить по файду конфигов
	 kubectl delete -f {config}.yaml